import os
import time
import schedule
from openai import OpenAI
import ccxt
import pandas as pd
import re
from dotenv import load_dotenv
import json
import requests
from datetime import datetime, timedelta

load_dotenv()

# åˆå§‹åŒ–DeepSeekå®¢æˆ·ç«¯
deepseek_client = OpenAI(
    api_key=os.getenv('DEEPSEEK_API_KEY'),
    base_url="https://api.deepseek.com"
)

# åˆå§‹åŒ–OKXäº¤æ˜“æ‰€
exchange = ccxt.okx({
    'options': {
        'defaultType': 'swap',  # OKXä½¿ç”¨swapè¡¨ç¤ºæ°¸çºŒåˆç´„
    },
    'apiKey': os.getenv('OKX_API_KEY'),
    'secret': os.getenv('OKX_SECRET'),
    'password': os.getenv('OKX_PASSWORD'),  # OKXéœ€è¦äº¤æ˜“å¯†ç¢¼
})

# äº¤æ˜“åƒæ•¸é…ç½® - å¤šäº¤æ˜“å°æ”¯æŒ
TRADE_CONFIG = {
    'symbols': [
        {
            'symbol': 'BTC/USDT:USDT',
            'name': 'æ¯”ç‰¹å¹£',
            'base_usdt_amount': 100,
            'leverage': 10,
        },
        {
            'symbol': 'ETH/USDT:USDT', 
            'name': 'ä»¥å¤ªåŠ',
            'base_usdt_amount': 50,
            'leverage': 10,
        },
        {
            'symbol': 'SOL/USDT:USDT',
            'name': 'Solana',
            'base_usdt_amount': 30,
            'leverage': 10,
        }
    ],
    'timeframe': '15m',  # ä½¿ç”¨15åˆ†é˜Kç·š
    'test_mode': False,  # æ¸¬è©¦æ¨¡å¼
    'data_points': 96,  # 24å°æ™‚æ•¸æ“šï¼ˆ96æ ¹15åˆ†é˜Kç·šï¼‰
    'analysis_periods': {
        'short_term': 20,  # çŸ­æœŸå‡ç·š
        'medium_term': 50,  # ä¸­æœŸå‡ç·š
        'long_term': 96  # é•·æœŸè¶¨å‹¢
    },
    # æ™ºèƒ½å€‰ä½åƒæ•¸
    'position_management': {
        'enable_intelligent_position': True,  # æ˜¯å¦å•Ÿç”¨æ™ºèƒ½å€‰ä½ç®¡ç†
        'high_confidence_multiplier': 1.5,
        'medium_confidence_multiplier': 1.0,
        'low_confidence_multiplier': 0.5,
        'max_position_ratio': 1000,  # å–®æ¬¡æœ€å¤§å€‰ä½æ¯”ä¾‹
        'trend_strength_multiplier': 1.2
    }
}

# å…¨å±€è®Šé‡å­˜å„²æ­·å²æ•¸æ“š
price_history = {}
signal_history = {}
position = {}

def setup_exchange():
    """è¨­ç½®äº¤æ˜“æ‰€åƒæ•¸ - å¼·åˆ¶å…¨å€‰æ¨¡å¼"""
    try:
        print("ğŸ” ç²å–åˆç´„è¦æ ¼...")
        markets = exchange.load_markets()
        
        for symbol_config in TRADE_CONFIG['symbols']:
            symbol = symbol_config['symbol']
            name = symbol_config['name']
            
            try:
                market = markets[symbol]
                contract_size = float(market['contractSize'])
                symbol_config['contract_size'] = contract_size
                symbol_config['min_amount'] = market['limits']['amount']['min']
                
                print(f"âœ… {name}åˆç´„è¦æ ¼: 1å¼µ = {contract_size} {symbol.split('/')[0]}")
                print(f"ğŸ“ æœ€å°äº¤æ˜“é‡: {symbol_config['min_amount']} å¼µ")

                # è¨­ç½®å–®å‘æŒå€‰æ¨¡å¼
                print(f"ğŸ”„ è¨­ç½®{name}å–®å‘æŒå€‰æ¨¡å¼...")
                try:
                    exchange.set_position_mode(False, symbol)  # Falseè¡¨ç¤ºå–®å‘æŒå€‰
                    print(f"âœ… å·²è¨­ç½®{name}å–®å‘æŒå€‰æ¨¡å¼")
                except Exception as e:
                    print(f"âš ï¸ è¨­ç½®{name}å–®å‘æŒå€‰æ¨¡å¼å¤±æ•— (å¯èƒ½å·²è¨­ç½®): {e}")

                # è¨­ç½®å…¨å€‰æ¨¡å¼å’Œæ§“æ¡¿
                print(f"âš™ï¸ è¨­ç½®{name}å…¨å€‰æ¨¡å¼å’Œæ§“æ¡¿...")
                exchange.set_leverage(
                    symbol_config['leverage'],
                    symbol,
                    {'mgnMode': 'cross'}  # å¼·åˆ¶å…¨å€‰æ¨¡å¼
                )
                print(f"âœ… å·²è¨­ç½®{name}å…¨å€‰æ¨¡å¼ï¼Œæ§“æ¡¿å€æ•¸: {symbol_config['leverage']}x")

            except Exception as e:
                print(f"âŒ {name}åˆç´„è¨­ç½®å¤±æ•—: {e}")
                continue

        # é©—è­‰è³¬æˆ¶è¨­ç½®
        print("ğŸ” é©—è­‰è³¬æˆ¶è¨­ç½®...")
        balance = exchange.fetch_balance()
        usdt_balance = balance['USDT']['free']
        print(f"ğŸ’° ç•¶å‰USDTé¤˜é¡: {usdt_balance:.2f}")

        # ç²å–ç•¶å‰æŒå€‰ç‹€æ…‹
        for symbol_config in TRADE_CONFIG['symbols']:
            current_pos = get_current_position(symbol_config['symbol'])
            if current_pos:
                print(f"ğŸ“¦ {symbol_config['name']}ç•¶å‰æŒå€‰: {current_pos['side']}å€‰ {current_pos['size']}å¼µ")
            else:
                print(f"ğŸ“¦ {symbol_config['name']}ç•¶å‰ç„¡æŒå€‰")

        print("ğŸ¯ ç¨‹åºé…ç½®å®Œæˆï¼šå…¨å€‰æ¨¡å¼ + å–®å‘æŒå€‰")
        return True

    except Exception as e:
        print(f"âŒ äº¤æ˜“æ‰€è¨­ç½®å¤±æ•—: {e}")
        import traceback
        traceback.print_exc()
        return False

def calculate_intelligent_position(signal_data, price_data, current_position, symbol_config):
    """è¨ˆç®—æ™ºèƒ½å€‰ä½å¤§å° - ä¿®å¾©ç‰ˆ"""
    config = TRADE_CONFIG['position_management']

    # å¦‚æœç¦ç”¨æ™ºèƒ½å€‰ä½ï¼Œä½¿ç”¨å›ºå®šå€‰ä½
    if not config.get('enable_intelligent_position', True):
        fixed_contracts = 0.1  # å›ºå®šå€‰ä½å¤§å°ï¼Œå¯ä»¥æ ¹æ“šéœ€è¦èª¿æ•´
        print(f"ğŸ”§ æ™ºèƒ½å€‰ä½å·²ç¦ç”¨ï¼Œä½¿ç”¨å›ºå®šå€‰ä½: {fixed_contracts} å¼µ")
        return fixed_contracts

    try:
        # ç²å–è³¬æˆ¶é¤˜é¡
        balance = exchange.fetch_balance()
        usdt_balance = balance['USDT']['free']

        # åŸºç¤USDTæŠ•å…¥
        base_usdt = symbol_config['base_usdt_amount']
        print(f"ğŸ’° å¯ç”¨USDTé¤˜é¡: {usdt_balance:.2f}, ä¸‹å–®åŸºæ•¸{base_usdt}")

        # æ ¹æ“šä¿¡å¿ƒç¨‹åº¦èª¿æ•´
        confidence_multiplier = {
            'HIGH': config['high_confidence_multiplier'],
            'MEDIUM': config['medium_confidence_multiplier'],
            'LOW': config['low_confidence_multiplier']
        }.get(signal_data['confidence'], 1.0)  # æ·»åŠ é»˜èªå€¼

        # æ ¹æ“šè¶¨å‹¢å¼·åº¦èª¿æ•´
        trend = price_data['trend_analysis'].get('overall', 'éœ‡ç›ªæ•´ç†')
        if trend in ['å¼·å‹¢ä¸Šæ¼²', 'å¼·å‹¢ä¸‹è·Œ']:
            trend_multiplier = config['trend_strength_multiplier']
        else:
            trend_multiplier = 1.0

        # æ ¹æ“šRSIç‹€æ…‹èª¿æ•´ï¼ˆè¶…è²·è¶…è³£å€åŸŸæ¸›å€‰ï¼‰
        rsi = price_data['technical_data'].get('rsi', 50)
        if rsi > 75 or rsi < 25:
            rsi_multiplier = 0.7
        else:
            rsi_multiplier = 1.0

        # è¨ˆç®—å»ºè­°æŠ•å…¥USDTé‡‘é¡
        suggested_usdt = base_usdt * confidence_multiplier * trend_multiplier * rsi_multiplier

        # é¢¨éšªç®¡ç†ï¼šä¸è¶…éç¸½è³‡é‡‘çš„æŒ‡å®šæ¯”ä¾‹
        max_usdt = usdt_balance * (config['max_position_ratio'] / 100)
        final_usdt = min(suggested_usdt, max_usdt)

        # æ­£ç¢ºçš„åˆç´„å¼µæ•¸è¨ˆç®—ï¼
        # å…¬å¼ï¼šåˆç´„å¼µæ•¸ = (æŠ•å…¥USDT) / (ç•¶å‰åƒ¹æ ¼ * åˆç´„ä¹˜æ•¸)
        contract_size = (final_usdt) / (price_data['price'] * symbol_config['contract_size'])

        print(f"ğŸ“Š å€‰ä½è¨ˆç®—è©³æƒ…:")
        print(f"   â””â”€ åŸºç¤USDT: {base_usdt}")
        print(f"   â””â”€ ä¿¡å¿ƒå€æ•¸: {confidence_multiplier}")
        print(f"   â””â”€ è¶¨å‹¢å€æ•¸: {trend_multiplier}")
        print(f"   â””â”€ RSIå€æ•¸: {rsi_multiplier}")
        print(f"   â””â”€ å»ºè­°USDT: {suggested_usdt:.2f}")
        print(f"   â””â”€ æœ€çµ‚USDT: {final_usdt:.2f}")
        print(f"   â””â”€ åˆç´„ä¹˜æ•¸: {symbol_config['contract_size']}")
        print(f"   â””â”€ è¨ˆç®—åˆç´„: {contract_size:.4f} å¼µ")

        # ç²¾åº¦è™•ç†ï¼šOKX BTCåˆç´„æœ€å°äº¤æ˜“å–®ä½ç‚º0.01å¼µ
        contract_size = round(contract_size, 2)  # ä¿ç•™2ä½å°æ•¸

        # ç¢ºä¿æœ€å°äº¤æ˜“é‡
        min_contracts = symbol_config.get('min_amount', 0.01)
        if contract_size < min_contracts:
            contract_size = min_contracts
            print(f"âš ï¸ å€‰ä½å°æ–¼æœ€å°å€¼ï¼Œèª¿æ•´ç‚º: {contract_size} å¼µ")

        print(f"ğŸ¯ æœ€çµ‚å€‰ä½: {final_usdt:.2f} USDT â†’ {contract_size:.2f} å¼µåˆç´„")
        return contract_size

    except Exception as e:
        print(f"âŒ å€‰ä½è¨ˆç®—å¤±æ•—ï¼Œä½¿ç”¨åŸºç¤å€‰ä½: {e}")
        # ç·Šæ€¥å‚™ç”¨è¨ˆç®—
        base_usdt = symbol_config['base_usdt_amount']
        contract_size = (base_usdt * symbol_config['leverage']) / (price_data['price'] * symbol_config.get('contract_size', 0.01))
        return round(max(contract_size, symbol_config.get('min_amount', 0.01)), 2)

def calculate_technical_indicators(df):
    """è¨ˆç®—æŠ€è¡“æŒ‡æ¨™ - åŒ…å«è£¸Kåˆ†æ"""
    try:
        # ç§»å‹•å¹³å‡ç·š
        df['sma_5'] = df['close'].rolling(window=5, min_periods=1).mean()
        df['sma_20'] = df['close'].rolling(window=20, min_periods=1).mean()
        df['sma_50'] = df['close'].rolling(window=50, min_periods=1).mean()

        # æŒ‡æ•¸ç§»å‹•å¹³å‡ç·š
        df['ema_12'] = df['close'].ewm(span=12).mean()
        df['ema_26'] = df['close'].ewm(span=26).mean()
        df['macd'] = df['ema_12'] - df['ema_26']
        df['macd_signal'] = df['macd'].ewm(span=9).mean()
        df['macd_histogram'] = df['macd'] - df['macd_signal']

        # ç›¸å°å¼·å¼±æŒ‡æ•¸ (RSI)
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(14).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))

        # å¸ƒæ—å¸¶
        df['bb_middle'] = df['close'].rolling(20).mean()
        bb_std = df['close'].rolling(20).std()
        df['bb_upper'] = df['bb_middle'] + (bb_std * 2)
        df['bb_lower'] = df['bb_middle'] - (bb_std * 2)
        df['bb_position'] = (df['close'] - df['bb_lower']) / (df['bb_upper'] - df['bb_lower'])

        # æˆäº¤é‡å‡ç·š
        df['volume_ma'] = df['volume'].rolling(20).mean()
        df['volume_ratio'] = df['volume'] / df['volume_ma']

        # æ”¯æ’é˜»åŠ›ä½
        df['resistance'] = df['high'].rolling(20).max()
        df['support'] = df['low'].rolling(20).min()

        # ğŸ†• è£¸Kåˆ†æ - Kç·šå½¢æ…‹è­˜åˆ¥
        df = calculate_naked_k_analysis(df)

        # å¡«å……NaNå€¼
        df = df.bfill().ffill()

        return df
    except Exception as e:
        print(f"æŠ€è¡“æŒ‡æ¨™è¨ˆç®—å¤±æ•—: {e}")
        return df

def calculate_naked_k_analysis(df):
    """è£¸Kåˆ†æ - è­˜åˆ¥é—œéµKç·šå½¢æ…‹"""
    try:
        # åˆå§‹åŒ–å½¢æ…‹åˆ—
        df['k_pattern'] = ''
        df['k_strength'] = 0
        
        for i in range(2, len(df)):
            # ç•¶å‰Kç·šæ•¸æ“š
            current = df.iloc[i]
            prev = df.iloc[i-1]
            prev2 = df.iloc[i-2]
            
            # è¨ˆç®—å¯¦é«”å’Œå½±ç·š
            current_body = abs(current['close'] - current['open'])
            current_upper_shadow = current['high'] - max(current['open'], current['close'])
            current_lower_shadow = min(current['open'], current['close']) - current['low']
            current_range = current['high'] - current['low']
            
            prev_body = abs(prev['close'] - prev['open'])
            prev_range = prev['high'] - prev['low']
            
            # éŒ˜å­ç·š/ä¸ŠåŠç·š (Hammer/Hanging Man)
            if (current_lower_shadow >= 2 * current_body and 
                current_upper_shadow <= current_body * 0.1 and
                current_range > 0):
                if current['close'] > current['open']:  # é™½ç·šéŒ˜å­
                    df.at[df.index[i], 'k_pattern'] = 'éŒ˜å­ç·š'
                    df.at[df.index[i], 'k_strength'] = 0.7
                else:  # é™°ç·šä¸ŠåŠç·š
                    df.at[df.index[i], 'k_pattern'] = 'ä¸ŠåŠç·š'
                    df.at[df.index[i], 'k_strength'] = -0.7
            
            # å°„æ“Šä¹‹æ˜Ÿ/å€’éŒ˜ç·š (Shooting Star/Inverted Hammer)
            elif (current_upper_shadow >= 2 * current_body and 
                  current_lower_shadow <= current_body * 0.1 and
                  current_range > 0):
                if current['close'] < current['open']:  # é™°ç·šå°„æ“Šä¹‹æ˜Ÿ
                    df.at[df.index[i], 'k_pattern'] = 'å°„æ“Šä¹‹æ˜Ÿ'
                    df.at[df.index[i], 'k_strength'] = -0.7
                else:  # é™½ç·šå€’éŒ˜ç·š
                    df.at[df.index[i], 'k_pattern'] = 'å€’éŒ˜ç·š'
                    df.at[df.index[i], 'k_strength'] = 0.7
            
            # åæ²’å½¢æ…‹ (Engulfing Pattern)
            elif (current_body > prev_body * 1.2 and
                  ((current['close'] > current['open'] and current['open'] < prev['close'] and current['close'] > prev['open']) or
                   (current['close'] < current['open'] and current['open'] > prev['close'] and current['close'] < prev['open']))):
                if current['close'] > current['open']:  # å¤šé ­åæ²’
                    df.at[df.index[i], 'k_pattern'] = 'å¤šé ­åæ²’'
                    df.at[df.index[i], 'k_strength'] = 0.8
                else:  # ç©ºé ­åæ²’
                    df.at[df.index[i], 'k_pattern'] = 'ç©ºé ­åæ²’'
                    df.at[df.index[i], 'k_strength'] = -0.8
            
            # çƒé›²è“‹é ‚ (Dark Cloud Cover)
            elif (current['close'] < current['open'] and prev['close'] > prev['open'] and
                  current['open'] > prev['close'] and current['close'] < (prev['open'] + prev['close']) / 2):
                df.at[df.index[i], 'k_pattern'] = 'çƒé›²è“‹é ‚'
                df.at[df.index[i], 'k_strength'] = -0.6
            
            # åˆºé€å½¢æ…‹ (Piercing Pattern)
            elif (current['close'] > current['open'] and prev['close'] < prev['open'] and
                  current['open'] < prev['low'] and current['close'] > (prev['open'] + prev['close']) / 2):
                df.at[df.index[i], 'k_pattern'] = 'åˆºé€å½¢æ…‹'
                df.at[df.index[i], 'k_strength'] = 0.6
            
            # åå­—æ˜Ÿ (Doji)
            elif current_body <= current_range * 0.1 and current_range > 0:
                df.at[df.index[i], 'k_pattern'] = 'åå­—æ˜Ÿ'
                df.at[df.index[i], 'k_strength'] = 0  # ä¸­æ€§ä¿¡è™Ÿ
            
            # å¤§é™½ç·š/å¤§é™°ç·š
            elif current_body > current_range * 0.6:
                if current['close'] > current['open']:
                    df.at[df.index[i], 'k_pattern'] = 'å¤§é™½ç·š'
                    df.at[df.index[i], 'k_strength'] = 0.5
                else:
                    df.at[df.index[i], 'k_pattern'] = 'å¤§é™°ç·š'
                    df.at[df.index[i], 'k_strength'] = -0.5
        
        return df
    except Exception as e:
        print(f"è£¸Kåˆ†æè¨ˆç®—å¤±æ•—: {e}")
        return df

def get_support_resistance_levels(df, lookback=20):
    """è¨ˆç®—æ”¯æ’é˜»åŠ›ä½"""
    try:
        recent_high = df['high'].tail(lookback).max()
        recent_low = df['low'].tail(lookback).min()
        current_price = df['close'].iloc[-1]

        resistance_level = recent_high
        support_level = recent_low

        # å‹•æ…‹æ”¯æ’é˜»åŠ›ï¼ˆåŸºæ–¼å¸ƒæ—å¸¶ï¼‰
        bb_upper = df['bb_upper'].iloc[-1]
        bb_lower = df['bb_lower'].iloc[-1]

        return {
            'static_resistance': resistance_level,
            'static_support': support_level,
            'dynamic_resistance': bb_upper,
            'dynamic_support': bb_lower,
            'price_vs_resistance': ((resistance_level - current_price) / current_price) * 100,
            'price_vs_support': ((current_price - support_level) / support_level) * 100
        }
    except Exception as e:
        print(f"æ”¯æ’é˜»åŠ›è¨ˆç®—å¤±æ•—: {e}")
        return {}

def get_sentiment_indicators(token="BTC"):
    """ç²å–æƒ…ç·’æŒ‡æ¨™ - ç°¡æ½”ç‰ˆæœ¬"""
    try:
        API_URL = "https://service.cryptoracle.network/openapi/v2/endpoint"
        API_KEY = "7ad48a56-8730-4238-a714-eebc30834e3e"

        # ç²å–æœ€è¿‘4å°æ™‚æ•¸æ“š
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=4)

        request_body = {
            "apiKey": API_KEY,
            "endpoints": ["CO-A-02-01", "CO-A-02-02"],  # åªä¿ç•™æ ¸å¿ƒæŒ‡æ¨™
            "startTime": start_time.strftime("%Y-%m-%d %H:%M:%S"),
            "endTime": end_time.strftime("%Y-%m-%d %H:%M:%S"),
            "timeType": "15m",
            "token": [token]
        }

        headers = {"Content-Type": "application/json", "X-API-KEY": API_KEY}
        response = requests.post(API_URL, json=request_body, headers=headers)

        if response.status_code == 200:
            data = response.json()
            if data.get("code") == 200 and data.get("data"):
                time_periods = data["data"][0]["timePeriods"]

                # æŸ¥æ‰¾ç¬¬ä¸€å€‹æœ‰æœ‰æ•ˆæ•¸æ“šçš„æ™‚é–“æ®µ
                for period in time_periods:
                    period_data = period.get("data", [])

                    sentiment = {}
                    valid_data_found = False

                    for item in period_data:
                        endpoint = item.get("endpoint")
                        value = item.get("value", "").strip()

                        if value:  # åªè™•ç†éç©ºå€¼
                            try:
                                if endpoint in ["CO-A-02-01", "CO-A-02-02"]:
                                    sentiment[endpoint] = float(value)
                                    valid_data_found = True
                            except (ValueError, TypeError):
                                continue

                    # å¦‚æœæ‰¾åˆ°æœ‰æ•ˆæ•¸æ“š
                    if valid_data_found and "CO-A-02-01" in sentiment and "CO-A-02-02" in sentiment:
                        positive = sentiment['CO-A-02-01']
                        negative = sentiment['CO-A-02-02']
                        net_sentiment = positive - negative

                        # æ­£ç¢ºçš„æ™‚é–“å»¶é²è¨ˆç®—
                        data_delay = int((datetime.now() - datetime.strptime(
                            period['startTime'], '%Y-%m-%d %H:%M:%S')).total_seconds() // 60)

                        print(f"âœ… ä½¿ç”¨æƒ…ç·’æ•¸æ“šæ™‚é–“: {period['startTime']} (å»¶é²: {data_delay}åˆ†é˜)")

                        return {
                            'positive_ratio': positive,
                            'negative_ratio': negative,
                            'net_sentiment': net_sentiment,
                            'data_time': period['startTime'],
                            'data_delay_minutes': data_delay
                        }

                print("âŒ æ‰€æœ‰æ™‚é–“æ®µæ•¸æ“šéƒ½ç‚ºç©º")
                return None

        return None
    except Exception as e:
        print(f"æƒ…ç·’æŒ‡æ¨™ç²å–å¤±æ•—: {e}")
        return None

def get_market_trend(df):
    """åˆ¤æ–·å¸‚å ´è¶¨å‹¢"""
    try:
        current_price = df['close'].iloc[-1]

        # å¤šæ™‚é–“æ¡†æ¶è¶¨å‹¢åˆ†æ
        trend_short = "ä¸Šæ¼²" if current_price > df['sma_20'].iloc[-1] else "ä¸‹è·Œ"
        trend_medium = "ä¸Šæ¼²" if current_price > df['sma_50'].iloc[-1] else "ä¸‹è·Œ"

        # MACDè¶¨å‹¢
        macd_trend = "bullish" if df['macd'].iloc[-1] > df['macd_signal'].iloc[-1] else "bearish"

        # è£¸Kä¿¡è™Ÿ
        k_pattern = df['k_pattern'].iloc[-1]
        k_strength = df['k_strength'].iloc[-1]

        # ç¶œåˆè¶¨å‹¢åˆ¤æ–·ï¼ˆåŠ å…¥è£¸Kæ¬Šé‡ï¼‰
        trend_score = 0
        if trend_short == "ä¸Šæ¼²": trend_score += 0.3
        if trend_medium == "ä¸Šæ¼²": trend_score += 0.3
        if macd_trend == "bullish": trend_score += 0.2
        trend_score += k_strength * 0.2  # è£¸Kæ¬Šé‡èˆ‡RSIç›¸åŒ

        if trend_score >= 0.6:
            overall_trend = "å¼·å‹¢ä¸Šæ¼²"
        elif trend_score <= -0.6:
            overall_trend = "å¼·å‹¢ä¸‹è·Œ"
        else:
            overall_trend = "éœ‡ç›ªæ•´ç†"

        return {
            'short_term': trend_short,
            'medium_term': trend_medium,
            'macd': macd_trend,
            'k_pattern': k_pattern,
            'k_strength': k_strength,
            'overall': overall_trend,
            'rsi_level': df['rsi'].iloc[-1],
            'trend_score': trend_score
        }
    except Exception as e:
        print(f"è¶¨å‹¢åˆ†æå¤±æ•—: {e}")
        return {}

def get_btc_ohlcv_enhanced(symbol_config):
    """å¢å¼·ç‰ˆï¼šç²å–Kç·šæ•¸æ“šä¸¦è¨ˆç®—æŠ€è¡“æŒ‡æ¨™"""
    try:
        # ç²å–Kç·šæ•¸æ“š
        ohlcv = exchange.fetch_ohlcv(symbol_config['symbol'], TRADE_CONFIG['timeframe'],
                                     limit=TRADE_CONFIG['data_points'])

        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

        # è¨ˆç®—æŠ€è¡“æŒ‡æ¨™ï¼ˆåŒ…å«è£¸Kåˆ†æï¼‰
        df = calculate_technical_indicators(df)

        current_data = df.iloc[-1]
        previous_data = df.iloc[-2]

        # ç²å–æŠ€è¡“åˆ†ææ•¸æ“š
        trend_analysis = get_market_trend(df)
        levels_analysis = get_support_resistance_levels(df)

        return {
            'price': current_data['close'],
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'high': current_data['high'],
            'low': current_data['low'],
            'volume': current_data['volume'],
            'timeframe': TRADE_CONFIG['timeframe'],
            'price_change': ((current_data['close'] - previous_data['close']) / previous_data['close']) * 100,
            'kline_data': df[['timestamp', 'open', 'high', 'low', 'close', 'volume', 'k_pattern']].tail(10).to_dict('records'),
            'technical_data': {
                'sma_5': current_data.get('sma_5', 0),
                'sma_20': current_data.get('sma_20', 0),
                'sma_50': current_data.get('sma_50', 0),
                'rsi': current_data.get('rsi', 0),
                'macd': current_data.get('macd', 0),
                'macd_signal': current_data.get('macd_signal', 0),
                'macd_histogram': current_data.get('macd_histogram', 0),
                'bb_upper': current_data.get('bb_upper', 0),
                'bb_lower': current_data.get('bb_lower', 0),
                'bb_position': current_data.get('bb_position', 0),
                'volume_ratio': current_data.get('volume_ratio', 0),
                'k_pattern': current_data.get('k_pattern', ''),
                'k_strength': current_data.get('k_strength', 0)
            },
            'trend_analysis': trend_analysis,
            'levels_analysis': levels_analysis,
            'full_data': df
        }
    except Exception as e:
        print(f"ç²å–å¢å¼·Kç·šæ•¸æ“šå¤±æ•—: {e}")
        return None

def generate_technical_analysis_text(price_data, symbol_name):
    """ç”ŸæˆæŠ€è¡“åˆ†ææ–‡æœ¬ - å„ªåŒ–æ’ç‰ˆ"""
    if 'technical_data' not in price_data:
        return "æŠ€è¡“æŒ‡æ¨™æ•¸æ“šä¸å¯ç”¨"

    tech = price_data['technical_data']
    trend = price_data.get('trend_analysis', {})
    levels = price_data.get('levels_analysis', {})

    # æª¢æŸ¥æ•¸æ“šæœ‰æ•ˆæ€§
    def safe_float(value, default=0):
        return float(value) if value and pd.notna(value) else default

    # ğŸ†• å„ªåŒ–æ’ç‰ˆè¼¸å‡º
    analysis_text = f"""
    ã€{symbol_name}æŠ€è¡“æŒ‡æ¨™åˆ†æã€‘
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”‚ ğŸ“ˆ ç§»å‹•å¹³å‡ç·š:
    â”‚   â”œâ”€ 5é€±æœŸ: {safe_float(tech['sma_5']):.2f} | ç›¸å°: {(price_data['price'] - safe_float(tech['sma_5'])) / safe_float(tech['sma_5']) * 100:+.2f}%
    â”‚   â”œâ”€ 20é€±æœŸ: {safe_float(tech['sma_20']):.2f} | ç›¸å°: {(price_data['price'] - safe_float(tech['sma_20'])) / safe_float(tech['sma_20']) * 100:+.2f}%
    â”‚   â””â”€ 50é€±æœŸ: {safe_float(tech['sma_50']):.2f} | ç›¸å°: {(price_data['price'] - safe_float(tech['sma_50'])) / safe_float(tech['sma_50']) * 100:+.2f}%
    â”‚
    â”‚ ğŸ¯ è¶¨å‹¢åˆ†æ:
    â”‚   â”œâ”€ çŸ­æœŸè¶¨å‹¢: {trend.get('short_term', 'N/A')}
    â”‚   â”œâ”€ ä¸­æœŸè¶¨å‹¢: {trend.get('medium_term', 'N/A')}
    â”‚   â”œâ”€ æ•´é«”è¶¨å‹¢: {trend.get('overall', 'N/A')}
    â”‚   â”œâ”€ MACDæ–¹å‘: {trend.get('macd', 'N/A')}
    â”‚   â””â”€ è¶¨å‹¢å¾—åˆ†: {trend.get('trend_score', 0):.2f}
    â”‚
    â”‚ ğŸ“Š å‹•é‡æŒ‡æ¨™:
    â”‚   â”œâ”€ RSI: {safe_float(tech['rsi']):.2f} ({'è¶…è²·' if safe_float(tech['rsi']) > 70 else 'è¶…è³£' if safe_float(tech['rsi']) < 30 else 'ä¸­æ€§'})
    â”‚   â”œâ”€ MACD: {safe_float(tech['macd']):.4f}
    â”‚   â””â”€ ä¿¡è™Ÿç·š: {safe_float(tech['macd_signal']):.4f}
    â”‚
    â”‚ ğŸ” è£¸Kåˆ†æ:
    â”‚   â”œâ”€ Kç·šå½¢æ…‹: {tech.get('k_pattern', 'ç„¡')}
    â”‚   â””â”€ å½¢æ…‹å¼·åº¦: {safe_float(tech.get('k_strength', 0)):.2f}
    â”‚
    â”‚ ğŸšï¸ å¸ƒæ—å¸¶ä½ç½®: {safe_float(tech['bb_position']):.2%} ({'ä¸Šéƒ¨' if safe_float(tech['bb_position']) > 0.7 else 'ä¸‹éƒ¨' if safe_float(tech['bb_position']) < 0.3 else 'ä¸­éƒ¨'})
    â”‚
    â”‚ ğŸ’° é—œéµæ°´å¹³:
    â”‚   â”œâ”€ éœæ…‹é˜»åŠ›: {safe_float(levels.get('static_resistance', 0)):.2f}
    â”‚   â”œâ”€ éœæ…‹æ”¯æ’: {safe_float(levels.get('static_support', 0)):.2f}
    â”‚   â”œâ”€ å‹•æ…‹é˜»åŠ›: {safe_float(levels.get('dynamic_resistance', 0)):.2f}
    â”‚   â””â”€ å‹•æ…‹æ”¯æ’: {safe_float(levels.get('dynamic_support', 0)):.2f}
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    """
    return analysis_text

def get_current_position(symbol):
    """ç²å–ç•¶å‰æŒå€‰æƒ…æ³ - OKXç‰ˆæœ¬"""
    try:
        positions = exchange.fetch_positions([symbol])

        for pos in positions:
            if pos['symbol'] == symbol:
                contracts = float(pos['contracts']) if pos['contracts'] else 0

                if contracts > 0:
                    return {
                        'side': pos['side'],  # 'long' or 'short'
                        'size': contracts,
                        'entry_price': float(pos['entryPrice']) if pos['entryPrice'] else 0,
                        'unrealized_pnl': float(pos['unrealizedPnl']) if pos['unrealizedPnl'] else 0,
                        'leverage': float(pos['leverage']) if pos['leverage'] else TRADE_CONFIG['symbols'][0]['leverage'],
                        'symbol': pos['symbol']
                    }

        return None

    except Exception as e:
        print(f"ç²å–æŒå€‰å¤±æ•—: {e}")
        import traceback
        traceback.print_exc()
        return None

def safe_json_parse(json_str):
    """å®‰å…¨è§£æJSONï¼Œè™•ç†æ ¼å¼ä¸è¦ç¯„çš„æƒ…æ³"""
    try:
        return json.loads(json_str)
    except json.JSONDecodeError:
        try:
            # ä¿®å¾©å¸¸è¦‹çš„JSONæ ¼å¼å•é¡Œ
            json_str = json_str.replace("'", '"')
            json_str = re.sub(r'(\w+):', r'"\1":', json_str)
            json_str = re.sub(r',\s*}', '}', json_str)
            json_str = re.sub(r',\s*]', ']', json_str)
            return json.loads(json_str)
        except json.JSONDecodeError as e:
            print(f"JSONè§£æå¤±æ•—ï¼ŒåŸå§‹å…§å®¹: {json_str}")
            print(f"éŒ¯èª¤è©³æƒ…: {e}")
            return None

def create_fallback_signal(price_data):
    """å‰µå»ºå‚™ç”¨äº¤æ˜“ä¿¡è™Ÿ"""
    return {
        "signal": "HOLD",
        "reason": "å› æŠ€è¡“åˆ†ææš«æ™‚ä¸å¯ç”¨ï¼Œæ¡å–ä¿å®ˆç­–ç•¥",
        "stop_loss": price_data['price'] * 0.98,  # -2%
        "take_profit": price_data['price'] * 1.02,  # +2%
        "confidence": "LOW",
        "is_fallback": True
    }

def analyze_with_deepseek(price_data, symbol_config):
    """ä½¿ç”¨DeepSeekåˆ†æå¸‚å ´ä¸¦ç”Ÿæˆäº¤æ˜“ä¿¡è™Ÿï¼ˆå¢å¼·ç‰ˆï¼‰"""

    symbol_name = symbol_config['name']
    
    # ç”ŸæˆæŠ€è¡“åˆ†ææ–‡æœ¬
    technical_analysis = generate_technical_analysis_text(price_data, symbol_name)

    # æ§‹å»ºKç·šæ•¸æ“šæ–‡æœ¬
    kline_text = f"ã€æœ€è¿‘5æ ¹{TRADE_CONFIG['timeframe']}Kç·šæ•¸æ“šã€‘\n"
    for i, kline in enumerate(price_data['kline_data'][-5:]):
        trend = "é™½ç·š" if kline['close'] > kline['open'] else "é™°ç·š"
        change = ((kline['close'] - kline['open']) / kline['open']) * 100
        k_pattern = kline.get('k_pattern', 'ç„¡')
        kline_text += f"Kç·š{i + 1}: {trend} é–‹:{kline['open']:.2f} æ”¶:{kline['close']:.2f} æ¼²è·Œ:{change:+.2f}% å½¢æ…‹:{k_pattern}\n"

    # æ·»åŠ ä¸Šæ¬¡äº¤æ˜“ä¿¡è™Ÿ
    signal_text = ""
    if symbol_config['symbol'] in signal_history and signal_history[symbol_config['symbol']]:
        last_signal = signal_history[symbol_config['symbol']][-1]
        signal_text = f"\nã€ä¸Šæ¬¡äº¤æ˜“ä¿¡è™Ÿã€‘\nä¿¡è™Ÿ: {last_signal.get('signal', 'N/A')}\nä¿¡å¿ƒ: {last_signal.get('confidence', 'N/A')}"

    # ç²å–æƒ…ç·’æ•¸æ“š
    token_map = {'BTC/USDT:USDT': 'BTC', 'ETH/USDT:USDT': 'ETH', 'SOL/USDT:USDT': 'SOL'}
    sentiment_data = get_sentiment_indicators(token_map.get(symbol_config['symbol'], 'BTC'))
    
    # ç°¡åŒ–æƒ…ç·’æ–‡æœ¬
    if sentiment_data:
        sign = '+' if sentiment_data['net_sentiment'] >= 0 else ''
        sentiment_text = f"ã€å¸‚å ´æƒ…ç·’ã€‘æ¨‚è§€{sentiment_data['positive_ratio']:.1%} æ‚²è§€{sentiment_data['negative_ratio']:.1%} æ·¨å€¼{sign}{sentiment_data['net_sentiment']:.3f}"
    else:
        sentiment_text = "ã€å¸‚å ´æƒ…ç·’ã€‘æ•¸æ“šæš«ä¸å¯ç”¨"

    # æ·»åŠ ç•¶å‰æŒå€‰ä¿¡æ¯
    current_pos = get_current_position(symbol_config['symbol'])
    position_text = "ç„¡æŒå€‰" if not current_pos else f"{current_pos['side']}å€‰, æ•¸é‡: {current_pos['size']}, ç›ˆè™§: {current_pos['unrealized_pnl']:.2f}USDT"
    pnl_text = f", æŒå€‰ç›ˆè™§: {current_pos['unrealized_pnl']:.2f} USDT" if current_pos else ""

    prompt = f"""
    ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„åŠ å¯†è²¨å¹£äº¤æ˜“åˆ†æå¸«ã€‚è«‹åŸºæ–¼ä»¥ä¸‹{symbol_name}/USDT {TRADE_CONFIG['timeframe']}é€±æœŸæ•¸æ“šé€²è¡Œåˆ†æï¼š

    {kline_text}

    {technical_analysis}

    {signal_text}

    {sentiment_text}  # æ·»åŠ æƒ…ç·’åˆ†æ

    ã€ç•¶å‰è¡Œæƒ…ã€‘
    - ç•¶å‰åƒ¹æ ¼: ${price_data['price']:,.2f}
    - æ™‚é–“: {price_data['timestamp']}
    - æœ¬Kç·šæœ€é«˜: ${price_data['high']:,.2f}
    - æœ¬Kç·šæœ€ä½: ${price_data['low']:,.2f}
    - æœ¬Kç·šæˆäº¤é‡: {price_data['volume']:.2f} {symbol_name}
    - åƒ¹æ ¼è®ŠåŒ–: {price_data['price_change']:+.2f}%
    - ç•¶å‰æŒå€‰: {position_text}{pnl_text}

    ã€é˜²é »ç¹äº¤æ˜“é‡è¦åŸå‰‡ã€‘
    1. **è¶¨å‹¢æŒçºŒæ€§å„ªå…ˆ**: ä¸è¦å› å–®æ ¹Kç·šæˆ–çŸ­æœŸæ³¢å‹•æ”¹è®Šæ•´é«”è¶¨å‹¢åˆ¤æ–·
    2. **æŒå€‰ç©©å®šæ€§**: é™¤éè¶¨å‹¢æ˜ç¢ºå¼·çƒˆåè½‰ï¼Œå¦å‰‡ä¿æŒç¾æœ‰æŒå€‰æ–¹å‘
    3. **åè½‰ç¢ºèª**: éœ€è¦è‡³å°‘2-3å€‹æŠ€è¡“æŒ‡æ¨™åŒæ™‚ç¢ºèªè¶¨å‹¢åè½‰æ‰æ”¹è®Šä¿¡è™Ÿ
    4. **æˆæœ¬æ„è­˜**: æ¸›å°‘ä¸å¿…è¦çš„å€‰ä½èª¿æ•´ï¼Œæ¯æ¬¡äº¤æ˜“éƒ½æœ‰æˆæœ¬

    ã€äº¤æ˜“æŒ‡å°åŸå‰‡ - å¿…é ˆéµå®ˆã€‘
    1. **æŠ€è¡“åˆ†æä¸»å°** (æ¬Šé‡60%)ï¼šè¶¨å‹¢ã€æ”¯æ’é˜»åŠ›ã€Kç·šå½¢æ…‹æ˜¯ä¸»è¦ä¾æ“š
    2. **å¸‚å ´æƒ…ç·’è¼”åŠ©** (æ¬Šé‡30%)ï¼šæƒ…ç·’æ•¸æ“šç”¨æ–¼é©—è­‰æŠ€è¡“ä¿¡è™Ÿï¼Œä¸èƒ½å–®ç¨ä½œç‚ºäº¤æ˜“ç†ç”±  
    3. **é¢¨éšªç®¡ç†** (æ¬Šé‡10%)ï¼šè€ƒæ…®æŒå€‰ã€ç›ˆè™§ç‹€æ³å’Œæ­¢æä½ç½®
    4. **è¶¨å‹¢è·Ÿéš¨**: æ˜ç¢ºè¶¨å‹¢å‡ºç¾æ™‚ç«‹å³è¡Œå‹•ï¼Œä¸è¦éåº¦ç­‰å¾…
    5. **è£¸Kåˆ†ææ¬Šé‡**: èˆ‡RSIç›¸åŒï¼Œé‡è¦å½¢æ…‹å¦‚åæ²’ã€éŒ˜å­ç·šç­‰æ‡‰çµ¦äºˆé‡è¦–
    6. **ä¿¡è™Ÿæ˜ç¢ºæ€§**:
    - å¼·å‹¢ä¸Šæ¼²è¶¨å‹¢ â†’ BUYä¿¡è™Ÿ
    - å¼·å‹¢ä¸‹è·Œè¶¨å‹¢ â†’ SELLä¿¡è™Ÿ  
    - åƒ…åœ¨çª„å¹…éœ‡ç›ªã€ç„¡æ˜ç¢ºæ–¹å‘æ™‚ â†’ HOLDä¿¡è™Ÿ
    7. **æŠ€è¡“æŒ‡æ¨™æ¬Šé‡**:
    - è¶¨å‹¢(å‡ç·šæ’åˆ—) > RSI = è£¸Kå½¢æ…‹ > MACD > å¸ƒæ—å¸¶
    - åƒ¹æ ¼çªç ´é—œéµæ”¯æ’/é˜»åŠ›ä½æ˜¯é‡è¦ä¿¡è™Ÿ 

    ã€ç•¶å‰æŠ€è¡“ç‹€æ³åˆ†æã€‘
    - æ•´é«”è¶¨å‹¢: {price_data['trend_analysis'].get('overall', 'N/A')}
    - çŸ­æœŸè¶¨å‹¢: {price_data['trend_analysis'].get('short_term', 'N/A')} 
    - RSIç‹€æ…‹: {price_data['technical_data'].get('rsi', 0):.1f} ({'è¶…è²·' if price_data['technical_data'].get('rsi', 0) > 70 else 'è¶…è³£' if price_data['technical_data'].get('rsi', 0) < 30 else 'ä¸­æ€§'})
    - MACDæ–¹å‘: {price_data['trend_analysis'].get('macd', 'N/A')}
    - è£¸Kå½¢æ…‹: {price_data['technical_data'].get('k_pattern', 'ç„¡')} (å¼·åº¦: {price_data['technical_data'].get('k_strength', 0):.2f})

    ã€æ™ºèƒ½å€‰ä½ç®¡ç†è¦å‰‡ - å¿…é ˆéµå®ˆã€‘

    1. **æ¸›å°‘éåº¦ä¿å®ˆ**ï¼š
       - æ˜ç¢ºè¶¨å‹¢ä¸­ä¸è¦å› è¼•å¾®è¶…è²·/è¶…è³£è€Œéåº¦HOLD
       - RSIåœ¨30-70å€é–“å±¬æ–¼å¥åº·ç¯„åœï¼Œä¸æ‡‰ä½œç‚ºä¸»è¦HOLDç†ç”±
       - å¸ƒæ—å¸¶ä½ç½®åœ¨20%-80%å±¬æ–¼æ­£å¸¸æ³¢å‹•å€é–“

    2. **è¶¨å‹¢è·Ÿéš¨å„ªå…ˆ**ï¼š
       - å¼·å‹¢ä¸Šæ¼²è¶¨å‹¢ + ä»»ä½•RSIå€¼ â†’ ç©æ¥µBUYä¿¡è™Ÿ
       - å¼·å‹¢ä¸‹è·Œè¶¨å‹¢ + ä»»ä½•RSIå€¼ â†’ ç©æ¥µSELLä¿¡è™Ÿ
       - éœ‡ç›ªæ•´ç† + ç„¡æ˜ç¢ºæ–¹å‘ â†’ HOLDä¿¡è™Ÿ

    3. **çªç ´äº¤æ˜“ä¿¡è™Ÿ**ï¼š
       - åƒ¹æ ¼çªç ´é—œéµé˜»åŠ› + æˆäº¤é‡æ”¾å¤§ â†’ é«˜ä¿¡å¿ƒBUY
       - åƒ¹æ ¼è·Œç ´é—œéµæ”¯æ’ + æˆäº¤é‡æ”¾å¤§ â†’ é«˜ä¿¡å¿ƒSELL

    4. **æŒå€‰å„ªåŒ–é‚è¼¯**ï¼š
       - å·²æœ‰æŒå€‰ä¸”è¶¨å‹¢å»¶çºŒ â†’ ä¿æŒæˆ–BUY/SELLä¿¡è™Ÿ
       - è¶¨å‹¢æ˜ç¢ºåè½‰ â†’ åŠæ™‚åå‘ä¿¡è™Ÿ
       - ä¸è¦å› ç‚ºå·²æœ‰æŒå€‰è€Œéåº¦HOLD

    ã€é‡è¦ã€‘è«‹åŸºæ–¼æŠ€è¡“åˆ†æåšå‡ºæ˜ç¢ºåˆ¤æ–·ï¼Œé¿å…å› éåº¦è¬¹æ…è€ŒéŒ¯éè¶¨å‹¢è¡Œæƒ…ï¼

    ã€åˆ†æè¦æ±‚ã€‘
    åŸºæ–¼ä»¥ä¸Šåˆ†æï¼Œè«‹çµ¦å‡ºæ˜ç¢ºçš„äº¤æ˜“ä¿¡è™Ÿ

    è«‹ç”¨ä»¥ä¸‹JSONæ ¼å¼å›è¦†ï¼š
    {{
        "signal": "BUY|SELL|HOLD",
        "reason": "ç°¡è¦åˆ†æç†ç”±(åŒ…å«è¶¨å‹¢åˆ¤æ–·å’ŒæŠ€è¡“ä¾æ“š)",
        "stop_loss": å…·é«”åƒ¹æ ¼,
        "take_profit": å…·é«”åƒ¹æ ¼, 
        "confidence": "HIGH|MEDIUM|LOW"
    }}
    """

    try:
        response = deepseek_client.chat.completions.create(
            model="deepseek-chat",
            messages=[
                {"role": "system",
                 "content": f"æ‚¨æ˜¯ä¸€ä½å°ˆæ¥­çš„äº¤æ˜“å“¡ï¼Œå°ˆæ³¨æ–¼{TRADE_CONFIG['timeframe']}é€±æœŸè¶¨å‹¢åˆ†æã€‚è«‹çµåˆKç·šå½¢æ…‹å’ŒæŠ€è¡“æŒ‡æ¨™åšå‡ºåˆ¤æ–·ï¼Œä¸¦åš´æ ¼éµå¾ªJSONæ ¼å¼è¦æ±‚ã€‚"},
                {"role": "user", "content": prompt}
            ],
            stream=False,
            temperature=0.1
        )

        # å®‰å…¨è§£æJSON
        result = response.choices[0].message.content
        print(f"DeepSeekåŸå§‹å›è¦†: {result}")

        # æå–JSONéƒ¨åˆ†
        start_idx = result.find('{')
        end_idx = result.rfind('}') + 1

        if start_idx != -1 and end_idx != 0:
            json_str = result[start_idx:end_idx]
            signal_data = safe_json_parse(json_str)

            if signal_data is None:
                signal_data = create_fallback_signal(price_data)
        else:
            signal_data = create_fallback_signal(price_data)

        # é©—è­‰å¿…éœ€å­—æ®µ
        required_fields = ['signal', 'reason', 'stop_loss', 'take_profit', 'confidence']
        if not all(field in signal_data for field in required_fields):
            signal_data = create_fallback_signal(price_data)

        # ä¿å­˜ä¿¡è™Ÿåˆ°æ­·å²è¨˜éŒ„
        if symbol_config['symbol'] not in signal_history:
            signal_history[symbol_config['symbol']] = []
        
        signal_data['timestamp'] = price_data['timestamp']
        signal_history[symbol_config['symbol']].append(signal_data)
        if len(signal_history[symbol_config['symbol']]) > 30:
            signal_history[symbol_config['symbol']].pop(0)

        # ä¿¡è™Ÿçµ±è¨ˆ
        current_signals = signal_history[symbol_config['symbol']]
        signal_count = len([s for s in current_signals if s.get('signal') == signal_data['signal']])
        total_signals = len(current_signals)
        print(f"ä¿¡è™Ÿçµ±è¨ˆ: {signal_data['signal']} (æœ€è¿‘{total_signals}æ¬¡ä¸­å‡ºç¾{signal_count}æ¬¡)")

        # ä¿¡è™Ÿé€£çºŒæ€§æª¢æŸ¥
        if len(current_signals) >= 3:
            last_three = [s['signal'] for s in current_signals[-3:]]
            if len(set(last_three)) == 1:
                print(f"âš ï¸ æ³¨æ„ï¼šé€£çºŒ3æ¬¡{signal_data['signal']}ä¿¡è™Ÿ")

        return signal_data

    except Exception as e:
        print(f"DeepSeekåˆ†æå¤±æ•—: {e}")
        return create_fallback_signal(price_data)

def execute_intelligent_trade(signal_data, price_data, symbol_config):
    """åŸ·è¡Œæ™ºèƒ½äº¤æ˜“ - OKXç‰ˆæœ¬ï¼ˆæ”¯æŒåŒæ–¹å‘åŠ å€‰æ¸›å€‰ï¼‰"""
    global position

    symbol = symbol_config['symbol']
    symbol_name = symbol_config['name']
    current_position = get_current_position(symbol)

    # è¨ˆç®—æ™ºèƒ½å€‰ä½
    position_size = calculate_intelligent_position(signal_data, price_data, current_position, symbol_config)

    print(f"ğŸ¯ {symbol_name}äº¤æ˜“ä¿¡è™Ÿ: {signal_data['signal']}")
    print(f"ğŸ“Š ä¿¡å¿ƒç¨‹åº¦: {signal_data['confidence']}")
    print(f"ğŸ’° æ™ºèƒ½å€‰ä½: {position_size:.2f} å¼µ")
    print(f"ğŸ“ ç†ç”±: {signal_data['reason']}")
    print(f"ğŸ“¦ ç•¶å‰æŒå€‰: {current_position}")

    # é¢¨éšªç®¡ç†
    if signal_data['confidence'] == 'LOW' and not TRADE_CONFIG['test_mode']:
        print("âš ï¸ ä½ä¿¡å¿ƒä¿¡è™Ÿï¼Œè·³éåŸ·è¡Œ")
        return

    if TRADE_CONFIG['test_mode']:
        print("æ¸¬è©¦æ¨¡å¼ - åƒ…æ¨¡æ“¬äº¤æ˜“")
        return

    try:
        # åŸ·è¡Œäº¤æ˜“é‚è¼¯ - æ”¯æŒåŒæ–¹å‘åŠ å€‰æ¸›å€‰
        if signal_data['signal'] == 'BUY':
            if current_position and current_position['side'] == 'short':
                # å…ˆæª¢æŸ¥ç©ºé ­æŒå€‰æ˜¯å¦çœŸå¯¦å­˜åœ¨ä¸”æ•¸é‡æ­£ç¢º
                if current_position['size'] > 0:
                    print(f"å¹³ç©ºå€‰ {current_position['size']:.2f} å¼µä¸¦é–‹å¤šå€‰ {position_size:.2f} å¼µ...")
                    # å¹³ç©ºå€‰
                    exchange.create_market_order(
                        symbol,
                        'buy',
                        current_position['size'],
                        params={'reduceOnly': True, 'tag': '60bb4a8d3416BCDE'}
                    )
                    time.sleep(1)
                    # é–‹å¤šå€‰
                    exchange.create_market_order(
                        symbol,
                        'buy',
                        position_size,
                        params={'tag': '60bb4a8d3416BCDE'}
                    )
                else:
                    print("âš ï¸ æª¢æ¸¬åˆ°ç©ºé ­æŒå€‰ä½†æ•¸é‡ç‚º0ï¼Œç›´æ¥é–‹å¤šå€‰")
                    exchange.create_market_order(
                        symbol,
                        'buy',
                        position_size,
                        params={'tag': '60bb4a8d3416BCDE'}
                    )

            elif current_position and current_position['side'] == 'long':
                # åŒæ–¹å‘ï¼Œæª¢æŸ¥æ˜¯å¦éœ€è¦èª¿æ•´å€‰ä½
                size_diff = position_size - current_position['size']

                if abs(size_diff) >= 0.01:  # æœ‰å¯èª¿æ•´çš„å·®ç•°
                    if size_diff > 0:
                        # åŠ å€‰
                        add_size = round(size_diff, 2)
                        print(f"å¤šå€‰åŠ å€‰ {add_size:.2f} å¼µ (ç•¶å‰:{current_position['size']:.2f} â†’ ç›®æ¨™:{position_size:.2f})")
                        exchange.create_market_order(
                            symbol,
                            'buy',
                            add_size,
                            params={'tag': '60bb4a8d3416BCDE'}
                        )
                    else:
                        # æ¸›å€‰
                        reduce_size = round(abs(size_diff), 2)
                        print(f"å¤šå€‰æ¸›å€‰ {reduce_size:.2f} å¼µ (ç•¶å‰:{current_position['size']:.2f} â†’ ç›®æ¨™:{position_size:.2f})")
                        exchange.create_market_order(
                            symbol,
                            'sell',
                            reduce_size,
                            params={'reduceOnly': True, 'tag': '60bb4a8d3416BCDE'}
                        )
                else:
                    print(f"å·²æœ‰å¤šé ­æŒå€‰ï¼Œå€‰ä½åˆé©ä¿æŒç¾ç‹€ (ç•¶å‰:{current_position['size']:.2f}, ç›®æ¨™:{position_size:.2f})")
            else:
                # ç„¡æŒå€‰æ™‚é–‹å¤šå€‰
                print(f"é–‹å¤šå€‰ {position_size:.2f} å¼µ...")
                exchange.create_market_order(
                    symbol,
                    'buy',
                    position_size,
                    params={'tag': '60bb4a8d3416BCDE'}
                )

        elif signal_data['signal'] == 'SELL':
            if current_position and current_position['side'] == 'long':
                # å…ˆæª¢æŸ¥å¤šé ­æŒå€‰æ˜¯å¦çœŸå¯¦å­˜åœ¨ä¸”æ•¸é‡æ­£ç¢º
                if current_position['size'] > 0:
                    print(f"å¹³å¤šå€‰ {current_position['size']:.2f} å¼µä¸¦é–‹ç©ºå€‰ {position_size:.2f} å¼µ...")
                    # å¹³å¤šå€‰
                    exchange.create_market_order(
                        symbol,
                        'sell',
                        current_position['size'],
                        params={'reduceOnly': True, 'tag': '60bb4a8d3416BCDE'}
                    )
                    time.sleep(1)
                    # é–‹ç©ºå€‰
                    exchange.create_market_order(
                        symbol,
                        'sell',
                        position_size,
                        params={'tag': '60bb4a8d3416BCDE'}
                    )
                else:
                    print("âš ï¸ æª¢æ¸¬åˆ°å¤šé ­æŒå€‰ä½†æ•¸é‡ç‚º0ï¼Œç›´æ¥é–‹ç©ºå€‰")
                    exchange.create_market_order(
                        symbol,
                        'sell',
                        position_size,
                        params={'tag': '60bb4a8d3416BCDE'}
                    )

            elif current_position and current_position['side'] == 'short':
                # åŒæ–¹å‘ï¼Œæª¢æŸ¥æ˜¯å¦éœ€è¦èª¿æ•´å€‰ä½
                size_diff = position_size - current_position['size']

                if abs(size_diff) >= 0.01:  # æœ‰å¯èª¿æ•´çš„å·®ç•°
                    if size_diff > 0:
                        # åŠ å€‰
                        add_size = round(size_diff, 2)
                        print(f"ç©ºå€‰åŠ å€‰ {add_size:.2f} å¼µ (ç•¶å‰:{current_position['size']:.2f} â†’ ç›®æ¨™:{position_size:.2f})")
                        exchange.create_market_order(
                            symbol,
                            'sell',
                            add_size,
                            params={'tag': '60bb4a8d3416BCDE'}
                        )
                    else:
                        # æ¸›å€‰
                        reduce_size = round(abs(size_diff), 2)
                        print(f"ç©ºå€‰æ¸›å€‰ {reduce_size:.2f} å¼µ (ç•¶å‰:{current_position['size']:.2f} â†’ ç›®æ¨™:{position_size:.2f})")
                        exchange.create_market_order(
                            symbol,
                            'buy',
                            reduce_size,
                            params={'reduceOnly': True, 'tag': '60bb4a8d3416BCDE'}
                        )
                else:
                    print(f"å·²æœ‰ç©ºé ­æŒå€‰ï¼Œå€‰ä½åˆé©ä¿æŒç¾ç‹€ (ç•¶å‰:{current_position['size']:.2f}, ç›®æ¨™:{position_size:.2f})")
            else:
                # ç„¡æŒå€‰æ™‚é–‹ç©ºå€‰
                print(f"é–‹ç©ºå€‰ {position_size:.2f} å¼µ...")
                exchange.create_market_order(
                    symbol,
                    'sell',
                    position_size,
                    params={'tag': '60bb4a8d3416BCDE'}
                )

        elif signal_data['signal'] == 'HOLD':
            print("å»ºè­°è§€æœ›ï¼Œä¸åŸ·è¡Œäº¤æ˜“")
            return

        print(f"âœ… {symbol_name}æ™ºèƒ½äº¤æ˜“åŸ·è¡ŒæˆåŠŸ")
        time.sleep(2)
        position[symbol] = get_current_position(symbol)
        print(f"ğŸ“¦ æ›´æ–°å¾ŒæŒå€‰: {position[symbol]}")

    except Exception as e:
        print(f"âŒ {symbol_name}äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")

        # å¦‚æœæ˜¯æŒå€‰ä¸å­˜åœ¨çš„éŒ¯èª¤ï¼Œå˜—è©¦ç›´æ¥é–‹æ–°å€‰
        if "don't have any positions" in str(e):
            print("å˜—è©¦ç›´æ¥é–‹æ–°å€‰...")
            try:
                if signal_data['signal'] == 'BUY':
                    exchange.create_market_order(
                        symbol,
                        'buy',
                        position_size,
                        params={'tag': '60bb4a8d3416BCDE'}
                    )
                elif signal_data['signal'] == 'SELL':
                    exchange.create_market_order(
                        symbol,
                        'sell',
                        position_size,
                        params={'tag': '60bb4a8d3416BCDE'}
                    )
                print("ç›´æ¥é–‹å€‰æˆåŠŸ")
            except Exception as e2:
                print(f"ç›´æ¥é–‹å€‰ä¹Ÿå¤±æ•—: {e2}")

        import traceback
        traceback.print_exc()

def analyze_with_deepseek_with_retry(price_data, symbol_config, max_retries=2):
    """å¸¶é‡è©¦çš„DeepSeekåˆ†æ"""
    for attempt in range(max_retries):
        try:
            signal_data = analyze_with_deepseek(price_data, symbol_config)
            if signal_data and not signal_data.get('is_fallback', False):
                return signal_data

            print(f"ç¬¬{attempt + 1}æ¬¡å˜—è©¦å¤±æ•—ï¼Œé€²è¡Œé‡è©¦...")
            time.sleep(1)

        except Exception as e:
            print(f"ç¬¬{attempt + 1}æ¬¡å˜—è©¦ç•°å¸¸: {e}")
            if attempt == max_retries - 1:
                return create_fallback_signal(price_data)
            time.sleep(1)

    return create_fallback_signal(price_data)

def wait_for_next_period():
    """ç­‰å¾…åˆ°ä¸‹ä¸€å€‹15åˆ†é˜æ•´é»"""
    now = datetime.now()
    current_minute = now.minute
    current_second = now.second

    # è¨ˆç®—ä¸‹ä¸€å€‹æ•´é»æ™‚é–“ï¼ˆ00, 15, 30, 45åˆ†é˜ï¼‰
    next_period_minute = ((current_minute // 15) + 1) * 15
    if next_period_minute == 60:
        next_period_minute = 0

    # è¨ˆç®—éœ€è¦ç­‰å¾…çš„ç¸½ç§’æ•¸
    if next_period_minute > current_minute:
        minutes_to_wait = next_period_minute - current_minute
    else:
        minutes_to_wait = 60 - current_minute + next_period_minute

    seconds_to_wait = minutes_to_wait * 60 - current_second

    # é¡¯ç¤ºå‹å¥½çš„ç­‰å¾…æ™‚é–“
    display_minutes = minutes_to_wait - 1 if current_second > 0 else minutes_to_wait
    display_seconds = 60 - current_second if current_second > 0 else 0

    if display_minutes > 0:
        print(f"ğŸ•’ ç­‰å¾… {display_minutes} åˆ† {display_seconds} ç§’åˆ°æ•´é»...")
    else:
        print(f"ğŸ•’ ç­‰å¾… {display_seconds} ç§’åˆ°æ•´é»...")

    return seconds_to_wait

def trading_bot_for_symbol(symbol_config):
    """å–®ä¸€äº¤æ˜“å°çš„äº¤æ˜“æ©Ÿå™¨äºº"""
    symbol_name = symbol_config['name']
    
    print(f"\n{'='*60}")
    print(f"ğŸ“Š é–‹å§‹åˆ†æ {symbol_name}")
    print(f"{'='*60}")

    # 1. ç²å–å¢å¼·ç‰ˆKç·šæ•¸æ“š
    price_data = get_btc_ohlcv_enhanced(symbol_config)
    if not price_data:
        print(f"âŒ ç„¡æ³•ç²å–{symbol_name}æ•¸æ“š")
        return

    print(f"ğŸ’° {symbol_name}ç•¶å‰åƒ¹æ ¼: ${price_data['price']:,.2f}")
    print(f"ğŸ“ˆ æ•¸æ“šé€±æœŸ: {TRADE_CONFIG['timeframe']}")
    print(f"ğŸ“Š åƒ¹æ ¼è®ŠåŒ–: {price_data['price_change']:+.2f}%")

    # 2. ä½¿ç”¨DeepSeekåˆ†æï¼ˆå¸¶é‡è©¦ï¼‰
    signal_data = analyze_with_deepseek_with_retry(price_data, symbol_config)

    if signal_data.get('is_fallback', False):
        print("âš ï¸ ä½¿ç”¨å‚™ç”¨äº¤æ˜“ä¿¡è™Ÿ")

    # 3. åŸ·è¡Œæ™ºèƒ½äº¤æ˜“
    execute_intelligent_trade(signal_data, price_data, symbol_config)

def trading_bot():
    """ä¸»äº¤æ˜“æ©Ÿå™¨äººå‡½æ•¸ - å¤šäº¤æ˜“å°ç‰ˆæœ¬"""
    # ç­‰å¾…åˆ°æ•´é»å†åŸ·è¡Œ
    wait_seconds = wait_for_next_period()
    if wait_seconds > 0:
        time.sleep(wait_seconds)

    print(f"\nğŸ¯ åŸ·è¡Œæ™‚é–“: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("ğŸŒŸ é–‹å§‹å¤šäº¤æ˜“å°åˆ†æ")

    # ç‚ºæ¯å€‹äº¤æ˜“å°åŸ·è¡Œäº¤æ˜“
    for symbol_config in TRADE_CONFIG['symbols']:
        try:
            trading_bot_for_symbol(symbol_config)
            time.sleep(2)  # äº¤æ˜“å°ä¹‹é–“ç¨ä½œåœé “
        except Exception as e:
            print(f"âŒ {symbol_config['name']}åˆ†æå¤±æ•—: {e}")
            continue

def main():
    """ä¸»å‡½æ•¸"""
    print("ğŸš€ BTC/ETH/SOL OKXè‡ªå‹•äº¤æ˜“æ©Ÿå™¨äººå•Ÿå‹•æˆåŠŸï¼")
    print("ğŸ“Š èåˆæŠ€è¡“æŒ‡æ¨™ç­–ç•¥ + è£¸Kåˆ†æ + OKXå¯¦ç›¤æ¥å£")

    if TRADE_CONFIG['test_mode']:
        print("ğŸ”¬ ç•¶å‰ç‚ºæ¨¡æ“¬æ¨¡å¼ï¼Œä¸æœƒçœŸå¯¦ä¸‹å–®")
    else:
        print("âš ï¸ å¯¦ç›¤äº¤æ˜“æ¨¡å¼ï¼Œè«‹è¬¹æ…æ“ä½œï¼")

    print(f"â° äº¤æ˜“é€±æœŸ: {TRADE_CONFIG['timeframe']}")
    print("âœ… å·²å•Ÿç”¨å®Œæ•´æŠ€è¡“æŒ‡æ¨™åˆ†æå’ŒæŒå€‰è·Ÿè¸ªåŠŸèƒ½")

    # é¡¯ç¤ºæ”¯æŒçš„äº¤æ˜“å°
    symbols_text = " | ".join([f"{config['name']}" for config in TRADE_CONFIG['symbols']])
    print(f"ğŸ¯ æ”¯æŒäº¤æ˜“å°: {symbols_text}")

    # è¨­ç½®äº¤æ˜“æ‰€
    if not setup_exchange():
        print("âŒ äº¤æ˜“æ‰€åˆå§‹åŒ–å¤±æ•—ï¼Œç¨‹åºé€€å‡º")
        return

    print("ğŸ”„ åŸ·è¡Œé »ç‡: æ¯15åˆ†é˜æ•´é»åŸ·è¡Œ")

    # å¾ªç’°åŸ·è¡Œï¼ˆä¸ä½¿ç”¨scheduleï¼‰
    while True:
        trading_bot()  # å‡½æ•¸å…§éƒ¨æœƒè‡ªå·±ç­‰å¾…æ•´é»

        # åŸ·è¡Œå®Œå¾Œç­‰å¾…ä¸€æ®µæ™‚é–“å†æª¢æŸ¥ï¼ˆé¿å…é »ç¹å¾ªç’°ï¼‰
        time.sleep(60)  # æ¯åˆ†é˜æª¢æŸ¥ä¸€æ¬¡

if __name__ == "__main__":
    main()
